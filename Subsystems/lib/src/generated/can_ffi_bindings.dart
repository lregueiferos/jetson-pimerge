// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for `src/burt_can`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen-can.yaml -v severe`.
///
class CanBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  CanBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  CanBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<BurtCan> BurtCan_create(
    ffi.Pointer<pkg_ffi.Utf8> interface1,
    int readTimeout,
    int type,
  ) {
    return _BurtCan_create(
      interface1,
      readTimeout,
      type,
    );
  }

  late final _BurtCan_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<BurtCan> Function(ffi.Pointer<pkg_ffi.Utf8>, ffi.Int32,
              ffi.Int32)>>('BurtCan_create');
  late final _BurtCan_create = _BurtCan_createPtr.asFunction<
      ffi.Pointer<BurtCan> Function(ffi.Pointer<pkg_ffi.Utf8>, int, int)>();

  void BurtCan_free(
    ffi.Pointer<BurtCan> pointer,
  ) {
    return _BurtCan_free(
      pointer,
    );
  }

  late final _BurtCan_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<BurtCan>)>>(
          'BurtCan_free');
  late final _BurtCan_free =
      _BurtCan_freePtr.asFunction<void Function(ffi.Pointer<BurtCan>)>();

  int BurtCan_open(
    ffi.Pointer<BurtCan> pointer,
  ) {
    return _BurtCan_open(
      pointer,
    );
  }

  late final _BurtCan_openPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<BurtCan>)>>(
          'BurtCan_open');
  late final _BurtCan_open =
      _BurtCan_openPtr.asFunction<int Function(ffi.Pointer<BurtCan>)>();

  int BurtCan_send(
    ffi.Pointer<BurtCan> pointer,
    ffi.Pointer<NativeCanMessage> message,
  ) {
    return _BurtCan_send(
      pointer,
      message,
    );
  }

  late final _BurtCan_sendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<BurtCan>,
              ffi.Pointer<NativeCanMessage>)>>('BurtCan_send');
  late final _BurtCan_send = _BurtCan_sendPtr.asFunction<
      int Function(ffi.Pointer<BurtCan>, ffi.Pointer<NativeCanMessage>)>();

  int BurtCan_receive(
    ffi.Pointer<BurtCan> pointer,
    ffi.Pointer<NativeCanMessage> message,
  ) {
    return _BurtCan_receive(
      pointer,
      message,
    );
  }

  late final _BurtCan_receivePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<BurtCan>,
              ffi.Pointer<NativeCanMessage>)>>('BurtCan_receive');
  late final _BurtCan_receive = _BurtCan_receivePtr.asFunction<
      int Function(ffi.Pointer<BurtCan>, ffi.Pointer<NativeCanMessage>)>();

  int BurtCan_close(
    ffi.Pointer<BurtCan> pointer,
  ) {
    return _BurtCan_close(
      pointer,
    );
  }

  late final _BurtCan_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<BurtCan>)>>(
          'BurtCan_close');
  late final _BurtCan_close =
      _BurtCan_closePtr.asFunction<int Function(ffi.Pointer<BurtCan>)>();

  ffi.Pointer<NativeCanMessage> NativeCanMessage_create() {
    return _NativeCanMessage_create();
  }

  late final _NativeCanMessage_createPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NativeCanMessage> Function()>>(
          'NativeCanMessage_create');
  late final _NativeCanMessage_create = _NativeCanMessage_createPtr.asFunction<
      ffi.Pointer<NativeCanMessage> Function()>();

  void NativeCanMessage_free(
    ffi.Pointer<NativeCanMessage> pointer,
  ) {
    return _NativeCanMessage_free(
      pointer,
    );
  }

  late final _NativeCanMessage_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NativeCanMessage>)>>(
      'NativeCanMessage_free');
  late final _NativeCanMessage_free = _NativeCanMessage_freePtr.asFunction<
      void Function(ffi.Pointer<NativeCanMessage>)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final CanBindings _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<BurtCan>)>>
      get BurtCan_free => _library._BurtCan_freePtr;
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NativeCanMessage>)>>
      get NativeCanMessage_free => _library._NativeCanMessage_freePtr;
}

abstract class BurtCanType {
  static const int CAN = 0;
  static const int CANFD = 1;
}

/// No 0 value to ensure we always set a status
abstract class BurtCanStatus {
  static const int OK = 1;

  /// Errors when opening and closing
  static const int SOCKET_CREATE_ERROR = 2;
  static const int INTERFACE_PARSE_ERROR = 3;
  static const int BIND_ERROR = 4;
  static const int CLOSE_ERROR = 5;

  /// CANFD errors
  static const int MTU_ERROR = 6;
  static const int CANFD_NOT_SUPPORTED = 7;
  static const int FD_MISC_ERROR = 8;

  /// IO errors
  static const int WRITE_ERROR = 9;
  static const int READ_ERROR = 10;
}

final class NativeCanMessage extends ffi.Struct {
  @ffi.Uint32()
  external int id;

  @ffi.Uint8()
  external int length;

  @ffi.Uint8()
  external int flags;

  external ffi.Pointer<ffi.Uint8> data;
}

final class BurtCan extends ffi.Opaque {}
